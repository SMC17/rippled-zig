//! Hook generation prototype: template-based Zig Hook → WASM
//! Usage: zig run tools/hook_gen.zig -- [template] [output]
//! Templates: accept_all, amount_min
//! Future: NL → template (requires LLM integration)

const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var args = try std.process.argsWithAllocator(allocator);
    defer args.deinit();

    _ = args.next(); // exe name
    const template = args.next() orelse "accept_all";
    const output_path = args.next();

    const source = if (std.mem.eql(u8, template, "amount_min"))
        amountMinTemplate()
    else
        acceptAllTemplate();

    const out = std.io.getStdOut().writer();
    if (output_path) |path| {
        var file = try std.fs.cwd().createFile(path, .{});
        defer file.close();
        try file.writeAll(source);
        try out.print("Wrote hook to {s}\n", .{path});
    } else {
        try out.writeAll(source);
    }
}

fn acceptAllTemplate() []const u8 {
    return
        \\//! XRPL Hooks - accept_all (generated by hook_gen)
        \\//! Build: zig build wasm
        \\
        \\export fn hook(reserved: u32) i64 {
        \\    _ = reserved;
        \\    return 0;
        \\}
        \\
        \\export fn cbak(what: u32) i64 {
        \\    _ = what;
        \\    return 0;
        \\}
        \\
    ;
}

fn amountMinTemplate() []const u8 {
    return
        \\//! XRPL Hooks - amount_min (reject payments below threshold)
        \\//! Build: zig build wasm
        \\//! TODO: Use Hook API (hook_param, etxn_details) to read tx amount and compare
        \\
        \\export fn hook(reserved: u32) i64 {
        \\    _ = reserved;
        \\    // Placeholder: read min from hook_param(0), compare tx amount via etxn_details
        \\    return 0;
        \\}
        \\
        \\export fn cbak(what: u32) i64 {
        \\    _ = what;
        \\    return 0;
        \\}
        \\
    ;
}
