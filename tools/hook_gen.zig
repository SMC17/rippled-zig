//! Hook generation prototype: template-based Zig Hook â†’ WASM
//! Usage: zig run tools/hook_gen.zig -- [template] [output]
//!        zig run tools/hook_gen.zig -- prompt "reject payments under 10 XRP"
//! Templates: accept_all, amount_min
//! NL mode: outputs a structured prompt for LLM to generate hook logic

const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var args = try std.process.argsWithAllocator(allocator);
    defer args.deinit();

    _ = args.next(); // exe name
    const cmd = args.next() orelse "accept_all";
    const output_path = args.next();

    const out = std.io.getStdOut().writer();

    if (std.mem.eql(u8, cmd, "prompt")) {
        const nl = args.next() orelse "accept all transactions";
        const prompt = try buildLlmPrompt(allocator, nl);
        defer allocator.free(prompt);
        if (output_path) |path| {
            var file = try std.fs.cwd().createFile(path, .{});
            defer file.close();
            try file.writeAll(prompt);
        } else {
            try out.writeAll(prompt);
        }
        return;
    }

    const source = if (std.mem.eql(u8, cmd, "amount_min"))
        amountMinTemplate()
    else
        acceptAllTemplate();

    if (output_path) |path| {
        var file = try std.fs.cwd().createFile(path, .{});
        defer file.close();
        try file.writeAll(source);
        try out.print("Wrote hook to {s}\n", .{path});
    } else {
        try out.writeAll(source);
    }
}

fn buildLlmPrompt(allocator: std.mem.Allocator, description: []const u8) ![]u8 {
    return std.fmt.allocPrint(allocator,
        \\Generate an XRPL Hooks Zig module based on this description:
        \\"{s}"
        \\
        \\Requirements:
        \\- Export fn hook(reserved: u32) i64
        \\- Export fn cbak(what: u32) i64
        \\- Return 0 = accept, 1 = rollback
        \\- Use Hook API: hook_param, etxn_details, etc. (extern "env")
        \\
        \\Output only valid Zig code, no markdown.
    , .{description});
}

fn acceptAllTemplate() []const u8 {
    return
        \\//! XRPL Hooks - accept_all (generated by hook_gen)
        \\//! Build: zig build wasm
        \\
        \\export fn hook(reserved: u32) i64 {
        \\    _ = reserved;
        \\    return 0;
        \\}
        \\
        \\export fn cbak(what: u32) i64 {
        \\    _ = what;
        \\    return 0;
        \\}
        \\
    ;
}

fn amountMinTemplate() []const u8 {
    return
        \\//! XRPL Hooks - amount_min (reject payments below threshold)
        \\//! Build: zig build wasm
        \\//! TODO: Use Hook API (hook_param, etxn_details) to read tx amount and compare
        \\
        \\export fn hook(reserved: u32) i64 {
        \\    _ = reserved;
        \\    // Placeholder: read min from hook_param(0), compare tx amount via etxn_details
        \\    return 0;
        \\}
        \\
        \\export fn cbak(what: u32) i64 {
        \\    _ = what;
        \\    return 0;
        \\}
        \\
    ;
}
